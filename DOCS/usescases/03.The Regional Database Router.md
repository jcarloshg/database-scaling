# The Regional Database Router

To implement this correctly in TypeScript, we need a **Regional Database Router**. Since the databases are physically distinct, the application must decide which connection pool to use at runtime based on the user's location or metadata.

### 1. The TypeScript Interfaces

First, we define our domain models. These match the SQL schema exactly.

```typescript
export interface User {
  id: string; // UUID
  username: string;
  email: string;
  password_hash: string;
  created_at: Date;
}

export interface Post {
  id: string; // UUID
  user_id: string;
  content: string;
  created_at: Date;
}

// Supported regions
export type Region = "US" | "EU" | "APAC" | "LATAM";
```

---

### 2. The Regional Database Router

In an expert-level system, you don't want to open and close connections constantly. We use a **Connection Pool Map** to keep persistent connections to all regional shards.

```typescript
import { Pool } from "pg";

class RegionalDbManager {
  private pools: Map<Region, Pool> = new Map();

  constructor() {
    // Initialize pools for each region
    const regions: Region[] = ["US", "EU", "APAC", "LATAM"];

    regions.forEach((region) => {
      this.pools.set(
        region,
        new Pool({
          connectionString: process.env[`DB_URL_${region}`],
          max: 20, // Connection pool limit per shard
          idleTimeoutMillis: 30000,
        })
      );
    });
  }

  /**
   * Main Router Method
   */
  async getClientForRegion(region: Region) {
    const pool = this.pools.get(region);
    if (!pool) throw new Error(`Unsupported region: ${region}`);
    return pool;
  }

  /**
   * Example: Save a post to a specific region
   */
  async createPost(
    region: Region,
    userId: string,
    content: string
  ): Promise<void> {
    const pool = await this.getClientForRegion(region);
    const query = `
      INSERT INTO posts (user_id, content) 
      VALUES ($1, $2)
    `;
    await pool.query(query, [userId, content]);
  }
}

export const dbRouter = new RegionalDbManager();
```

---

### 3. Solving the "Where is this User?" Problem

Since you have different databases, a major challenge is knowing which database to query when a user tries to log in. You have two expert-level options:

#### Option A: The "Region-Aware" Token (Best for Speed)

When a user registers, they are assigned a region. You bake that region into their JWT (JSON Web Token).

- **Pros:** Instant routing. No extra lookups.
- **Cons:** Hard to change a user's region later.

#### Option B: The Global Discovery Service (Best for Flexibility)

You maintain a tiny, ultra-fast table (using **Redis** or a small **Global Postgres Shard**) that only maps `username -> region`.

```typescript
/**
 * Pseudo-code for Login using a Discovery Service
 */
async function login(username: string) {
  // 1. Check Global Discovery Service (Redis) to find WHERE the user lives
  const region = (await globalCache.get(`user_region:${username}`)) as Region;

  if (!region) throw new Error("User not found");

  // 2. Route the request to the correct regional database
  const pool = await dbRouter.getClientForRegion(region);
  const user = await pool.query("SELECT * FROM users WHERE username = $1", [
    username,
  ]);

  return user.rows[0];
}
```

---

### ðŸ“‹ Strategy Summary for System Design

| Feature         | Expert Implementation   | Why?                                                                          |
| --------------- | ----------------------- | ----------------------------------------------------------------------------- |
| **Auth**        | JWT with `region` claim | Eliminates the need for a global lookup on every API call.                    |
| **Failover**    | Health checks per pool  | If a regional shard is down, the app can return a "Localized Outage" message. |
| **Consistency** | UUIDs + UTC Time        | Allows for easy data merging or "Home Region" migration in the future.        |

**Would you like me to create the Express/Fastify middleware that automatically detects the region from the request headers?**
