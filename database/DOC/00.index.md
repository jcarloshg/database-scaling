Since you are deploying separate physical databases per region (Geographic Sharding), each database will share the same schema. Using **UUIDs** is the correct expert choice here, as it prevents ID collisions if you ever need to migrate data between regional shards or aggregate data into a global warehouse for analytics.

Here is the clean, optimized PostgreSQL schema.

---

### SQL Schema Definition

```sql
-- Enable the pgcrypto or uuid-ossp extension to generate UUIDs
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 1. Users Table
-- Designed for high-speed lookups and strict regional isolation
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL, -- Never store raw "pass", always hash
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- Performance optimization: index for login lookups
    CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- 2. Posts Table
-- Linked to the regional user via UUID
CREATE TABLE posts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL, -- The "simple text" requirement
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    -- Constraint to prevent empty posts
    CONSTRAINT content_not_empty CHECK (trim(content) <> '')
);

-- Indexing for performance
-- High-concurrency systems need an index on the foreign key to speed up feed retrieval
CREATE INDEX idx_posts_user_id ON posts(user_id);
-- Index by timestamp to show latest posts first (Speed Use Case)
CREATE INDEX idx_posts_created_at ON posts(created_at DESC);

```

---

### Key Architectural Insights for this Schema

* **UUID v4 for Sharding:** By using `gen_random_uuid()`, you ensure that a User ID created in **Shard EU** will never conflict with a User ID created in **Shard Asia**. This is vital for the **"Capacity" Use Case** you described.
* **Timezone Awareness:** I used `TIMESTAMP WITH TIME ZONE`. In a geographic sharding scenario, users from different regions will be interacting. Storing everything in UTC/TZ-aware format prevents logic errors when calculating "real-time" feeds across regions.
* **Cascade Deletes:** `ON DELETE CASCADE` is used so that if a user exercises their "Right to be Forgotten" (GDPR - **Legal Use Case**), deleting the user automatically wipes their regional posts.
* **Indexing Strategy:** * The index on `user_id` in the `posts` table ensures that when a user views their own profile, the query is  rather than .
* The index on `created_at` ensures the **"Speed" Use Case** is met when fetching the most recent posts.



---

### Expert Recommendation for "Cross-Region" Logic

Since you are not using partitions but **entirely different databases**, your Application Layer (Node/TS) needs a **Regional Router**.

1. **The Router:** Before connecting to a DB, your code should look at the user's `region_claim` (from a JWT or IP) and select the correct Connection String.
2. **Global Search:** If you ever need to find a user without knowing their region, you will need a **Global Edge Index** (like a small DynamoDB or Redis Global table) that maps `username -> region_id`.

Would you like me to provide the **TypeScript Interfaces** and a **Database Service** that handles the dynamic regional routing?